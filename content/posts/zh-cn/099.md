---
title: "SICP 习题集 + 回答"
subtitle: 
date: 2022-08-29T21:06:03+02:00
draft: false
tags: ["SICP", "scheme"]
categories: ["生命不息 折腾不止"]
image: 
description: 
libraries:
- katex
---

<!-- 
![](https://mogeko.github.io/blog-images/r/099/)
{{< spoiler >}}{{< /spoiler >}}
&emsp;&emsp;
 -->

开始学习 [SICP](https://zh.wikipedia.org/wiki/计算机程序的构造和解释) 了！

做一个试题集来记录自己学习。

随便做了个签到表，监督自己每天打卡，至少看一章。

## 习题

### 1.1.6 条件表达式和谓词

#### 练习 1.1

(位于书中第 13 页)

下面是一系列表达式，对于每个表达式，解释器将输出什么结果？假定这一系列表达式是按照给出的顺序逐个求值的。

```scheme
10                              ;; 10

(+ 5 3 4)                       ;; 12

(- 9 1)                         ;; 8

(/ 6 2)                         ;; 3

(+ (* 2 4) (- 4 6))             ;; 6

(define a 3)                    ;; a

(define b (+ a 1))              ;; b

(+ a b (* a b))                 ;; 19

(= a b)                         ;; #f

(if (and > b a) (< b (* a b)))
    b
    a)                          ;; 4

(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))                ;; 16

(+ 2 (if (> b a) b a))          ;; 6

(* (cond ((> a b) a)
         ((< a b) b)
         (else -1))
    (+ a 1))                    ;; 16
```

#### 练习 1.2

(位于书中第 13 页)

请将下面表达式变换为前缀形式：

$$ \frac{5+4+(2-(3-(6+\frac{4}{5})))}{3(6-2)(2-7)} $$

```scheme
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5)))))
   (* 3 (- 6 2) (- 2 7)))
```

#### 练习 1.3

(位于书中第 13 页)

请定义一个过程，它以三个数为参数，返回其中较大的两个数之和。

```scheme
(define (sum-of-two-biggies a b c)
  (define (bigger x y)  (if (> x y) x y))
  (define (smaller x y) (if (> x y) y x))
  (+ (bigger a b)
     (bigger (smaller a b) c)))
```

#### 练习 1.4

(位于书中第 13 页)

请仔细考察上面给出的允许运算符为复合表达式的组合式的求值模型，根据对这一模型的认识描述下面的行为：

```scheme
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
```

定义一个函数 `a-plus-abs-b`；对于参数 `a` 和 `b`，如果 `b > 0`，返回 `a + b`，否则返回 `a - b`。

测试：

```scheme
(a-plus-abs-b 2 -3) ;; 5

(a-plus-abs-b 2 2)  ;; 4
```

#### 练习 1.5

(位于书中第 13 页)

Ben Bitdiddle 发明了一种检测方法，能够确定解释器究竟采用哪种序求值，是采用应用序，还是采用正则序。它定义了下面两个过程。

```scheme
(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))
```

然后他求值下面的表达式：

```scheme
(test 0 (p))
```

如果某个解释器采用的是应用序求值，Ben 会看到什么样的情况？如果解释器采用正则序求值，他又会看到什么情况？请对你的对回答做出解释。(无论采用正则序或者应用序，假定特殊形式 `if` 的求值规则总是一样的。其中谓词部分先行求值，根据其结果确定随后求值的子表达式部分。)

如果采用的是应用序求值，程序会陷入**死循环**，因为应用序在调用函数时求值，在执行 `(test 0 (p))` 时，函数 `p` 会被立即执行，然后进入死循环。

如果采用正则序求值，这会**输出 0**，因为正则序的解释器会先将函数 `(test 0 (p))` 展开成 `(if (= 0 0) 0 (p))`；然后根据特殊形式 `if` 的求值规则，谓词部分先被执行，结果为 `#t`；然后直接返回 `0`，函数 `p` 不会被执行。

(to be continue...)

## 附录

### Attendance

<!-- 
| Sun. | Mon. | Tue. | Wed. | Thur. | Fri. | Sat. |
|------|------|------|------|-------|------|------|
|      |      |      |      |       |      |      |
✅
 -->

#### August

| Sun. | Mon. | Tue. | Wed. | Thur. | Fri. | Sat. |
|------|------|------|------|-------|------|------|
| 28 ✅ | 29 ✅ | 30   | 31   |       |      |      |

#### September

| Sun. | Mon. | Tue. | Wed. | Thur. | Fri. | Sat. |
|------|------|------|------|-------|------|------|
|      |      |      |      | 01    | 02   | 03   |
| 04   | 05   | 06   | 07   | 08    | 09   | 10   |
| 11   | 12   | 13   | 14   | 15    | 16   | 17   |
| 18   | 19   | 20   | 21   | 22    | 23   | 24   |
| 25   | 26   | 27   | 28   | 29    | 30   |      |
