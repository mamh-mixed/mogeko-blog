---
title: "SICP 习题集 + 回答"
subtitle: 
date: 2022-08-29T21:06:03+02:00
draft: false
tags: ["SICP", "scheme", "lisp"]
categories: ["生命不息 折腾不止"]
image: 
description: 
tocLevels: ["h2", "h3", "h4", "h5"]
libraries:
- katex
---

<!-- 
![](https://mogeko.github.io/blog-images/r/099/)
{{< spoiler >}}{{< /spoiler >}}
&emsp;&emsp;
 -->

开始学习 [SICP](https://zh.wikipedia.org/wiki/计算机程序的构造和解释) 了！

做一个试题集来记录自己学习。

随便做了个签到表，监督自己每天打卡，每天至少看一节。

## 1.1 程序设计的基本元素

### 1.1.6 条件表达式和谓词

#### 练习 1.1

(位于书中第 13 页)

下面是一系列表达式，对于每个表达式，解释器将输出什么结果？假定这一系列表达式是按照给出的顺序逐个求值的。

```scheme
10                              ;; 10

(+ 5 3 4)                       ;; 12

(- 9 1)                         ;; 8

(/ 6 2)                         ;; 3

(+ (* 2 4) (- 4 6))             ;; 6

(define a 3)                    ;; a

(define b (+ a 1))              ;; b

(+ a b (* a b))                 ;; 19

(= a b)                         ;; #f

(if (and > b a) (< b (* a b)))
    b
    a)                          ;; 4

(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))                ;; 16

(+ 2 (if (> b a) b a))          ;; 6

(* (cond ((> a b) a)
         ((< a b) b)
         (else -1))
    (+ a 1))                    ;; 16
```

#### 练习 1.2

(位于书中第 13 页)

请将下面表达式变换为前缀形式：

$$ \frac{5+4+(2-(3-(6+\frac{4}{5})))}{3(6-2)(2-7)} $$

```scheme
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5)))))
   (* 3 (- 6 2) (- 2 7)))
```

#### 练习 1.3

(位于书中第 13 页)

请定义一个过程，它以三个数为参数，返回其中较大的两个数之和。

```scheme
(define (sum-of-two-biggies a b c)
  (define (bigger x y)  (if (> x y) x y))
  (define (smaller x y) (if (> x y) y x))
  (+ (bigger a b)
     (bigger (smaller a b) c)))
```

#### 练习 1.4

(位于书中第 13 页)

请仔细考察上面给出的允许运算符为复合表达式的组合式的求值模型，根据对这一模型的认识描述下面的行为：

```scheme
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
```

定义一个函数 `a-plus-abs-b`；对于参数 `a` 和 `b`，如果 `b > 0`，返回 `a + b`，否则返回 `a - b`。

测试：

```scheme
(a-plus-abs-b 2 -3) ;; 5

(a-plus-abs-b 2 2)  ;; 4
```

#### 练习 1.5

(位于书中第 13 页)

Ben Bitdiddle 发明了一种检测方法，能够确定解释器究竟采用哪种序求值，是采用应用序，还是采用正则序。它定义了下面两个过程。

```scheme
(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))
```

然后他求值下面的表达式：

```scheme
(test 0 (p))
```

如果某个解释器采用的是应用序求值，Ben 会看到什么样的情况？如果解释器采用正则序求值，他又会看到什么情况？请对你的对回答做出解释。(无论采用正则序或者应用序，假定特殊形式 `if` 的求值规则总是一样的。其中谓词部分先行求值，根据其结果确定随后求值的子表达式部分。)

如果采用的是应用序求值，程序会陷入**死循环**，因为应用序在调用函数时求值，在执行 `(test 0 (p))` 时，函数 `p` 会被立即执行，然后进入死循环。

如果采用正则序求值，这会**输出 0**，因为正则序的解释器会先将函数 `(test 0 (p))` 展开成 `(if (= 0 0) 0 (p))`；然后根据特殊形式 `if` 的求值规则，谓词部分先被执行，结果为 `#t`；然后直接返回 `0`，函数 `p` 不会被执行。

### 1.1.7 实例：采用牛顿法求平方根

#### 练习 1.6

(位于书中第 16 页)

Alyssa P. Hacker 看不出为什么需要将 `if` 提供为一种特殊形式，她问：“为什么我不能直接通过 `cond` 将它定义为一个常规过程呢？” Alyssa 的朋友 Eva Lu Ator 断言确实可以这样做，并定义了一个 `if` 的新版本：

```scheme
(define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
        (else      else-clause)))
```

Eva 给 Alyssa 演示她的程序：

```scheme
(new-if (= 2 3) 0 5) ;; 5

(new-if (= 1 1) 0 5) ;; 0
```

她很高兴地用自己的 `new-if` 重写了求平方根的程序：

```scheme
(define (sqrt-item guess x)
  (new-if (good-enough? guess x)
      guess
      (sqrt-item (improve guess x) x)))
```

当 Alyssa 试着用这个过程去计算平方根时会发生什么事件呢？请给出解释。

会因为**递归层数太深，超过了最大的递归深度**而强制退出。

在特殊形式 `if` 中 (我们假定特殊形式 `if` 的函数签名为 `(define (if (predicate then-clause else-clause)) (...))`)，程序会根据 `predicate` 的结果来决定执行 `then-clause` 或是 `else-clause`。但在 `new-if` 中，由于 `new-if` 是普通函数，所以无论 `predicate` 的结果如何，`then-clause` 和 `else-clause` 都会被执行，于是就轻松点超过了最大递归深度而被强制退出了。

#### 练习 1.7

(位于书中第 16 页)

对于确定很小的数的平方根而言，在计算平方根中使用的检测 `good-enough?` 是很不好的。还有，在现实的计算机里，算术运算总是以一定的有限精度进行的。这也会使我们的检测不适合非常大的数的计算。请解释上述论断，用例子说明对很小和很大的数，这种检测都可能失败。实现 `good-enough?` 的另一种策略是监视猜测值在从一次选代到下一次的变化情况，当改变值相对于猜测值的比率很小时就结束。请设计一个采用这种终止测试方式的平方根过程。对于很大和很小的数，这一方式都能工作吗？

由于我使用的是猜测值的平方与计算值的差小于 `0.01` 作为判断成功的条件。但测试值很小时，以 `0.01` 作为判断目标所产生的误差就会很大。例如：

```scheme
(sqrt 0.00009) ;; 得到 0.06297740362374088；正确值应当是 0.007745968689668512
```

而对于很大的值，由于 Scheme 的小数精度是有限的，如果两数的差值超过了 Scheme 的小树精度，程序会陷入死循环。

```scheme
(sqrt 8935827881491184718748172411241129912848) ;; 死循环
```

对于**监视猜测值在从一次选代到下一次的变化情况，当改变值相对于猜测值的比率很小时就结束**这种终止策略的实现：

```scheme
(define (good-enough? old new)
  (> 0.01 (/ (abs (- new old)) old)))

(define (sqrt-item guess x)
  (define new-guess (improve guess x))
  (if (good-enough? guess new-guess)
      new-guess
      (sqrt-item new-guess x)))
```

对于很大和很小的数，这一方式也能很好的工作！

```scheme
(sqrt 0.00009) ;; 0.009486833049684392

(writeln (sqrt 8935827881491184718748172411241129912848)) ;; 9.453022025155877e+19
```

#### 练习 1.8

(位于书中第 17 页)

求立方根的牛顿法基于如下事实，如果 $y$ 是 $x$ 的立方根的一个近似值，那么下式将给出一个更好的近似值：

$$ \frac{x/y^{2} + 2y}{3} $$

请利用这一公式实现一个类似平方根过程的求立方根的过程。

```scheme
(define (good-enough? old new)
  (> 0.01 (/ (abs (- new old)) old)))

(define (sqrt3-item guess x)
  (define new-guess (better-guess guess x))
  (if (good-enough? guess new-guess)
      new-guess
      (sqrt3-item new-guess x)))

(define (better-guess y x)
  (/ (+ (/ x (square y)) (* 2 y)) 3))

(define (sqrt3 x)
  (sqrt3-item 1.0 x))
```

测试：

```scheme
(sqrt3 1000) ;; 10.000000145265767

(sqrt3 371289471892) ;; 7187.3964104921715
```

## 1.2 过程与它们所产生的计算

### 1.2.1 线性的递归和迭代

#### 练习 1.9

(位于书中第 23 页)

下面几个过程各定义了一种加起两个正整数的方法，它们都基于过程 `inc` (它将参数增加1) 和 `dec` (它将参数减少1)。

```scheme
(define (+ a b)
  (if (= a 0)
      b
      (inc (+ (dec a) c))))

(define (+ a b)
  (if (= a 0)
      b
      (+ (dec a) (inc b))))
```

请用代换模型展示这两个过程在求值 `(+ 4 5)` 时所产生的计算过程。这些计算过程是递归的或者选代的吗？

对于方法一，有如下代换模型：

```scheme
(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (+ 0 5))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
```

这种方法是**线性递归的**。

对于方法二，有如下代换模型：

```scheme
(+ 4 5)
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9
```

这种方法是**线性迭代的**。

#### 练习 1.10

(位于书中第 24 页)

下面过程计算一个成为 Ackermann 函数的数学函数：

```scheme
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))
```

下面各表达式的值是什么：

```scheme
(A 1 10)

(A 2 4)

(A 3 3)
```

请考虑下面的过程，其中的 `A` 就是上面定义的过程：

```scheme
(define (f n) (A 0 n))

(define (g n) (A 1 n))

(define (h n) (A 2 n))

(define (k n) (* 5 n n))
```

请给出过程 `f`、`g` 和 `h` 对给定整数值 `n` 所计算的函数的数学定义。(例如，`(k n)` 计算的是 $5n^{2}$)

```scheme
(A 1 10) ;; 1024

(A 2 4)  ;; 65536

(A 3 3)  ;; 65536
```

我们将 `(f n)` 通过代换模型的方法展开：

```scheme
(f n)
(A 0 n)
(* 2 n)
```

我们可以得出过程 `f` 对给定整数值 `n` 所计算的函数的数学定义为：$ f(n)=2n $

将 `(g n)` 通过代换模型的方法展开：

```scheme
(g n)
(A 1 n)
(A 0 (A 1 (- n 1)))
(A 0 (A 0 (A 1 (- (- n 1) 1))))
...
```

通过观察我们可以得出：$ g(n)=2^n $

根据 $f(n)$ 和 $g(n)$，我们推测 $ h(n)=2^{2^{\ldotp^{\ldotp^{\ldotp^2}}}} $

将整数带入进行验算：

| $n$    | $0$ | $1$ | $2$ | $3$  | $4$     | $5$            | $\dots$ |
|--------|-----|-----|-----|------|---------|----------------|--------|
| $h(n)$ | $0$ | $2$ | $4$ | $16$ | $65536$ | $200\dots6736$ | $\dots$ |

基本可以验证我们的推测。

### 1.2.2 树形递归

#### 练习 1.11

(位于书中第 27 页)

函数 $f$ 由如下的规则定义：如果 $ n＜3 $，那么 $ f(n)=n $；如果 $ n\geq3 $，那么 $ f(n)=f(n-1)+2f(n-2)+3f(n-3) $。请写一个采用递归计算过程计算 $f$ 的过程。再写一个采用迭代计算过程计算 $f$ 的过程。

采用递归计算过程计算 $f$：

```scheme
(define (f n)
  (if (>= n 3)
      (+ (f (- n 1)) (* 2 (f (- n 2))) (* 3 (f (- n 3))))
      n))
```

验证：

| $n$    | $0$ | $1$ | $2$ | $3$ | $4$  | $5$  | $6$  | $7$   | $8$   | $9$   | $\dots$ |
|--------|-----|-----|-----|-----|------|------|------|-------|-------|-------|---------|
| $f(n)$ | $0$ | $1$ | $2$ | $4$ | $11$ | $25$ | $59$ | $142$ | $335$ | $796$ | $\dots$ |

至于通过迭代计算过程计算 $f$，我们先将一些简单的大于等于 $3$ 的整数代入到 $f$：

$$ f(3) = f(2) + 2f(1) + f(0) \newline f(4) = f(3) + 2f(2) + f(1) \newline f(5) = f(4) + 2f(3) + f(2) \newline\dots $$

通过观察，我们发现：

- $f(5)$ 的 $f(n-1)$ 和 $f(n-2)$ 是 $f(4)$ 和 $f(3)$
- $f(4)$ 的 $f(n-1)$ 是 $f(3)$
- ...

当 $ n\geq3 $ 时，所有函数 $f$ 的计算结果都可以用比当前 $n$ 更小的三个 $f$ 计算出来。

$$ f(i+3) = f(i+2) + 2f(i+1) + 3f(i) \pod{i = 1,2,3,\dots,n-3; n\geq3}$$

根据变形后的 $f$，我们令参数 `a`、`b`、`c`、`i` 分别表示 $f(i+2)$、$f(i+1)$、$f(i)$、$i$。

然后从 $f(0)$ 开始，一步步计算出 $f(n)$：

```scheme
(define (f n)
  (define (f-iter a b c i)
    (if (= n i)
        c
        (f-iter (+ a (* 2 b) (* 3 c)) ;; new a
                a                     ;; new b
                b                     ;; new c
                (+ i 1))))
  (f-iter 2 1 0 0))
```

验证：

| $n$    | $0$ | $1$ | $2$ | $3$ | $4$  | $5$  | $6$  | $7$   | $8$   | $9$   | $\dots$ |
|--------|-----|-----|-----|-----|------|------|------|-------|-------|-------|---------|
| $f(n)$ | $0$ | $1$ | $2$ | $4$ | $11$ | $25$ | $59$ | $142$ | $335$ | $796$ | $\dots$ |

(to be continue...)

## 附录

### Attendance

<!-- 
| Sun. | Mon. | Tue. | Wed. | Thur. | Fri. | Sat. |
|------|------|------|------|-------|------|------|
|      |      |      |      |       |      |      |
 -->

 <!-- ✅ -->

#### August

| Sun. | Mon. | Tue. | Wed. | Thur. | Fri. | Sat. |
|------|------|------|------|-------|------|------|
| 28 ✅ | 29 ✅ | 30 ✅ | 31   |       |      |      |

#### September

| Sun. | Mon. | Tue. | Wed. | Thur. | Fri. | Sat. |
|------|------|------|------|-------|------|------|
|      |      |      |      | 01    | 02   | 03   |
| 04   | 05   | 06   | 07   | 08    | 09   | 10   |
| 11   | 12   | 13   | 14   | 15    | 16   | 17   |
| 18   | 19   | 20   | 21   | 22    | 23   | 24   |
| 25   | 26   | 27   | 28   | 29    | 30   |      |
